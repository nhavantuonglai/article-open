"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils = require("../../utils");
const client_1 = require("../../dataconnect/client");
const prompts_1 = require("../../dataconnect/prompts");
const schemaMigration_1 = require("../../dataconnect/schemaMigration");
async function default_1(context, options) {
    const serviceInfos = context.dataconnect.serviceInfos;
    const filters = context.dataconnect.filters;
    const wantSchemas = serviceInfos
        .filter((si) => {
        return (!filters ||
            filters.some((f) => {
                return f.serviceId === si.dataConnectYaml.serviceId && (f.schemaOnly || f.fullService);
            }));
    })
        .map((s) => s.schema);
    if (wantSchemas.length) {
        utils.logLabeledBullet("dataconnect", "Releasing Data Connect schemas...");
        for (const s of wantSchemas) {
            await (0, schemaMigration_1.migrateSchema)({
                options,
                schema: s,
                validateOnly: false,
            });
        }
        utils.logLabeledBullet("dataconnect", "Schemas released.");
    }
    let wantConnectors = [];
    wantConnectors = wantConnectors.concat(...serviceInfos.map((si) => si.connectorInfo
        .filter((c) => {
        return (!filters ||
            filters.some((f) => {
                return (f.serviceId === si.dataConnectYaml.serviceId &&
                    (f.connectorId === c.connectorYaml.connectorId || f.fullService));
            }));
    })
        .map((c) => c.connector)));
    const haveConnectors = await have(serviceInfos);
    const connectorsToDelete = filters
        ? []
        : haveConnectors.filter((h) => !wantConnectors.some((w) => w.name === h.name));
    if (wantConnectors.length) {
        utils.logLabeledBullet("dataconnect", "Releasing connectors...");
        await Promise.all(wantConnectors.map(async (c) => {
            await (0, client_1.upsertConnector)(c);
            utils.logLabeledSuccess("dataconnect", `Deployed connector ${c.name}`);
        }));
        for (const c of connectorsToDelete) {
            await (0, prompts_1.promptDeleteConnector)(options, c.name);
        }
        utils.logLabeledBullet("dataconnect", "Connectors released.");
    }
    utils.logLabeledSuccess("dataconnect", "Deploy complete!");
    return;
}
exports.default = default_1;
async function have(serviceInfos) {
    let connectors = [];
    for (const si of serviceInfos) {
        connectors = connectors.concat(await (0, client_1.listConnectors)(si.serviceName));
    }
    return connectors;
}
