"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickService = exports.readGQLFiles = exports.readConnectorYaml = exports.readDataConnectYaml = exports.readFirebaseJson = void 0;
const fs = require("fs-extra");
const path = require("path");
const error_1 = require("../error");
const utils_1 = require("../utils");
const load_1 = require("./load");
function readFirebaseJson(config) {
    if (!config.has("dataconnect")) {
        return [];
    }
    const validator = (cfg) => {
        if (!cfg["source"] && !cfg["location"]) {
            throw new error_1.FirebaseError("Invalid firebase.json: DataConnect requires `source` and `location`");
        }
        return {
            source: cfg["source"],
            location: cfg["location"],
        };
    };
    const configs = config.get("dataconnect");
    if (typeof configs === "object" && !Array.isArray(configs)) {
        return [validator(configs)];
    }
    else if (Array.isArray(configs)) {
        return configs.map(validator);
    }
    else {
        throw new error_1.FirebaseError("Invalid firebase.json: dataconnect should be of the form { source: string, location: string }");
    }
}
exports.readFirebaseJson = readFirebaseJson;
async function readDataConnectYaml(sourceDirectory) {
    const file = await (0, utils_1.readFileFromDirectory)(sourceDirectory, "dataconnect.yaml");
    const dataconnectYaml = await (0, utils_1.wrappedSafeLoad)(file.source);
    return validateDataConnectYaml(dataconnectYaml);
}
exports.readDataConnectYaml = readDataConnectYaml;
function validateDataConnectYaml(unvalidated) {
    return unvalidated;
}
async function readConnectorYaml(sourceDirectory) {
    const file = await (0, utils_1.readFileFromDirectory)(sourceDirectory, "connector.yaml");
    const connectorYaml = await (0, utils_1.wrappedSafeLoad)(file.source);
    return validateConnectorYaml(connectorYaml);
}
exports.readConnectorYaml = readConnectorYaml;
function validateConnectorYaml(unvalidated) {
    return unvalidated;
}
async function readGQLFiles(sourceDir) {
    const files = await fs.readdir(sourceDir);
    return files
        .filter((f) => f.endsWith(".gql") || f.endsWith(".graphql"))
        .map((f) => toFile(sourceDir, f));
}
exports.readGQLFiles = readGQLFiles;
function toFile(sourceDir, relPath) {
    const fullPath = path.join(sourceDir, relPath);
    if (!fs.existsSync(fullPath)) {
        throw new error_1.FirebaseError(`file ${fullPath} not found`);
    }
    const content = fs.readFileSync(fullPath).toString();
    return {
        path: relPath,
        content,
    };
}
async function pickService(projectId, config, serviceId) {
    const serviceCfgs = readFirebaseJson(config);
    let serviceInfo;
    if (serviceCfgs.length === 0) {
        throw new error_1.FirebaseError("No Data Connect services found in firebase.json.");
    }
    else if (serviceCfgs.length === 1) {
        serviceInfo = await (0, load_1.load)(projectId, serviceCfgs[0].location, serviceCfgs[0].source);
    }
    else {
        if (!serviceId) {
            throw new error_1.FirebaseError("Multiple Data Connect services found in firebase.json. Please specify a service ID to use.");
        }
        const infos = await Promise.all(serviceCfgs.map((c) => (0, load_1.load)(projectId, c.location, c.source)));
        const maybe = infos.find((i) => i.dataConnectYaml.serviceId === serviceId);
        if (!maybe) {
            throw new error_1.FirebaseError(`No service named ${serviceId} declared in firebase.json.`);
        }
        serviceInfo = maybe;
    }
    return serviceInfo;
}
exports.pickService = pickService;
