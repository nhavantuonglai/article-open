"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.firebaseowner = exports.setupIAMUser = exports.execute = void 0;
const pg = require("pg");
const cloud_sql_connector_1 = require("@google-cloud/cloud-sql-connector");
const requireAuth_1 = require("../../requireAuth");
const projectUtils_1 = require("../../projectUtils");
const cloudSqlAdminClient = require("./cloudsqladmin");
const utils = require("../../utils");
const logger_1 = require("../../logger");
const error_1 = require("../../error");
const fbToolsAuthClient_1 = require("./fbToolsAuthClient");
async function execute(sqlStatements, opts) {
    const logFn = opts.silent ? logger_1.logger.debug : logger_1.logger.info;
    const instance = await cloudSqlAdminClient.getInstance(opts.projectId, opts.instanceId);
    const user = await cloudSqlAdminClient.getUser(opts.projectId, opts.instanceId, opts.username);
    const connectionName = instance.connectionName;
    if (!connectionName) {
        throw new error_1.FirebaseError(`Could not get instance connection string for ${opts.instanceId}:${opts.databaseId}`);
    }
    let connector;
    let pool;
    switch (user.type) {
        case "CLOUD_IAM_USER": {
            connector = new cloud_sql_connector_1.Connector({
                auth: new fbToolsAuthClient_1.FBToolsAuthClient(),
            });
            const clientOpts = await connector.getOptions({
                instanceConnectionName: connectionName,
                ipType: cloud_sql_connector_1.IpAddressTypes.PUBLIC,
                authType: cloud_sql_connector_1.AuthTypes.IAM,
            });
            pool = new pg.Pool(Object.assign(Object.assign({}, clientOpts), { user: opts.username, database: opts.databaseId }));
            break;
        }
        case "CLOUD_IAM_SERVICE_ACCOUNT": {
            connector = new cloud_sql_connector_1.Connector();
            const clientOpts = await connector.getOptions({
                instanceConnectionName: connectionName,
                ipType: cloud_sql_connector_1.IpAddressTypes.PUBLIC,
                authType: cloud_sql_connector_1.AuthTypes.IAM,
            });
            pool = new pg.Pool(Object.assign(Object.assign({}, clientOpts), { user: opts.username, database: opts.databaseId }));
            break;
        }
        default: {
            if (!opts.password) {
                throw new error_1.FirebaseError(`Cannot connect as BUILT_IN user without a password.`);
            }
            connector = new cloud_sql_connector_1.Connector({
                auth: new fbToolsAuthClient_1.FBToolsAuthClient(),
            });
            const clientOpts = await connector.getOptions({
                instanceConnectionName: connectionName,
                ipType: cloud_sql_connector_1.IpAddressTypes.PUBLIC,
            });
            pool = new pg.Pool(Object.assign(Object.assign({}, clientOpts), { user: opts.username, password: opts.password, database: opts.databaseId }));
            break;
        }
    }
    const conn = await pool.connect();
    logFn(`Logged in as ${opts.username}`);
    for (const s of sqlStatements) {
        logFn(`Executing: '${s}'`);
        try {
            await conn.query(s);
        }
        catch (err) {
            throw new error_1.FirebaseError(`Error executing ${err}`);
        }
    }
    conn.release();
    await pool.end();
    connector.close();
}
exports.execute = execute;
async function setupIAMUser(instanceId, databaseId, options) {
    const projectId = (0, projectUtils_1.needProjectId)(options);
    const account = await (0, requireAuth_1.requireAuth)(options);
    if (!account) {
        throw new error_1.FirebaseError("No account to set up! Run `firebase login` or set Application Default Credentials");
    }
    const setupUser = "firebasesuperuser";
    const temporaryPassword = utils.generateId(20);
    await cloudSqlAdminClient.createUser(projectId, instanceId, "BUILT_IN", setupUser, temporaryPassword);
    const { user, mode } = toDatabaseUser(account);
    await cloudSqlAdminClient.createUser(projectId, instanceId, mode, user);
    const grants = [
        `do
      $$
      begin
        if not exists (select FROM pg_catalog.pg_roles
          WHERE  rolname = '${firebaseowner(databaseId)}') then
          CREATE ROLE "${firebaseowner(databaseId)}" WITH ADMIN "${setupUser}";
        end if;
      end
      $$
      ;`,
        `GRANT ALL PRIVILEGES ON DATABASE "${databaseId}" TO "${firebaseowner(databaseId)}"`,
        `GRANT cloudsqlsuperuser TO "${firebaseowner(databaseId)}"`,
        `GRANT "${firebaseowner(databaseId)}" TO "${setupUser}"`,
        `GRANT "${firebaseowner(databaseId)}" TO "${user}"`,
        `ALTER SCHEMA public OWNER TO "${firebaseowner(databaseId)}"`,
        `GRANT USAGE ON SCHEMA "public" TO PUBLIC`,
        `GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA "public" TO PUBLIC`,
        `GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA "public" TO PUBLIC`,
    ];
    await execute(grants, {
        projectId,
        instanceId,
        databaseId,
        username: setupUser,
        password: temporaryPassword,
        silent: true,
    });
    return user;
}
exports.setupIAMUser = setupIAMUser;
function firebaseowner(databaseId) {
    return `firebaseowner_${databaseId}_public`;
}
exports.firebaseowner = firebaseowner;
function toDatabaseUser(account) {
    let mode = "CLOUD_IAM_USER";
    let user = account;
    if (account.endsWith(".gserviceaccount.com")) {
        user = account.replace(".gserviceaccount.com", "");
        mode = "CLOUD_IAM_SERVICE_ACCOUNT";
    }
    return { user, mode };
}
