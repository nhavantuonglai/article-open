"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doSetup = void 0;
const path_1 = require("path");
const clc = require("colorette");
const prompt_1 = require("../../../prompt");
const provisionCloudSql_1 = require("../../../dataconnect/provisionCloudSql");
const freeTrial_1 = require("../../../dataconnect/freeTrial");
const cloudsql = require("../../../gcp/cloudsql/cloudsqladmin");
const ensureApis_1 = require("../../../dataconnect/ensureApis");
const client_1 = require("../../../dataconnect/client");
const emulators_1 = require("../emulators");
const names_1 = require("../../../dataconnect/names");
const logger_1 = require("../../../logger");
const templates_1 = require("../../../templates");
const utils_1 = require("../../../utils");
const DATACONNECT_YAML_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/dataconnect.yaml");
const CONNECTOR_YAML_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/connector.yaml");
const SCHEMA_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/schema.gql");
const QUERIES_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/queries.gql");
const MUTATIONS_TEMPLATE = (0, templates_1.readTemplateSync)("init/dataconnect/mutations.gql");
async function doSetup(setup, config) {
    var _a, _b, _c;
    let info = {
        serviceId: "",
        locationId: "",
        cloudSqlInstanceId: "",
        isNewInstance: false,
        cloudSqlDatabase: "",
        isNewDatabase: false,
        connectorId: "default-connector",
    };
    info = await promptForService(setup, info);
    if (info.cloudSqlInstanceId === "") {
        info = await promptForCloudSQLInstance(setup, info);
    }
    if (info.cloudSqlDatabase === "") {
        info = await promptForDatabase(setup, config, info);
    }
    const defaultConnectionString = (_c = (_b = (_a = setup.rcfile.dataconnectEmulatorConfig) === null || _a === void 0 ? void 0 : _a.postgres) === null || _b === void 0 ? void 0 : _b.localConnectionString) !== null && _c !== void 0 ? _c : emulators_1.DEFAULT_POSTGRES_CONNECTION;
    const localConnectionString = await (0, prompt_1.promptOnce)({
        type: "input",
        name: "localConnectionString",
        message: `What is the connection string of the local Postgres instance you would like to use with the Data Connect emulator?`,
        default: defaultConnectionString,
    });
    setup.rcfile.dataconnectEmulatorConfig = { postgres: { localConnectionString } };
    const dir = config.get("dataconnect.source") || "dataconnect";
    const subbedDataconnectYaml = subValues(DATACONNECT_YAML_TEMPLATE, info);
    const subbedConnectorYaml = subValues(CONNECTOR_YAML_TEMPLATE, info);
    config.set("dataconnect", { source: dir });
    await config.askWriteProjectFile((0, path_1.join)(dir, "dataconnect.yaml"), subbedDataconnectYaml);
    await config.askWriteProjectFile((0, path_1.join)(dir, "schema", "schema.gql"), SCHEMA_TEMPLATE);
    await config.askWriteProjectFile((0, path_1.join)(dir, info.connectorId, "connector.yaml"), subbedConnectorYaml);
    await config.askWriteProjectFile((0, path_1.join)(dir, info.connectorId, "queries.gql"), QUERIES_TEMPLATE);
    await config.askWriteProjectFile((0, path_1.join)(dir, info.connectorId, "mutations.gql"), MUTATIONS_TEMPLATE);
    if (setup.projectId &&
        (info.isNewInstance || info.isNewDatabase) &&
        (await (0, prompt_1.confirm)({
            message: "Would you like to provision your CloudSQL instance and database now? This will take a few minutes.",
            default: true,
        }))) {
        await (0, provisionCloudSql_1.provisionCloudSql)({
            projectId: setup.projectId,
            locationId: info.locationId,
            instanceId: info.cloudSqlInstanceId,
            databaseId: info.cloudSqlDatabase,
            enableGoogleMlIntegration: false,
            waitForCreation: false,
        });
    }
    logger_1.logger.info("");
    (0, utils_1.logSuccess)(`If you'd like to generate an SDK for your new connector, run ${clc.bold("firebase init dataconnect:sdk")}`);
}
exports.doSetup = doSetup;
function subValues(template, replacementValues) {
    const replacements = {
        serviceId: "__serviceId__",
        cloudSqlDatabase: "__cloudSqlDatabase__",
        cloudSqlInstanceId: "__cloudSqlInstanceId__",
        connectorId: "__connectorId__",
        locationId: "__location__",
    };
    let replaced = template;
    for (const [k, v] of Object.entries(replacementValues)) {
        replaced = replaced.replace(replacements[k], v);
    }
    return replaced;
}
async function promptForService(setup, info) {
    var _a, _b, _c, _d;
    if (setup.projectId) {
        await (0, ensureApis_1.ensureApis)(setup.projectId);
        const existingServices = await (0, client_1.listAllServices)(setup.projectId);
        const existingServicesAndSchemas = await Promise.all(existingServices.map(async (s) => {
            return {
                service: s,
                schema: await (0, client_1.getSchema)(s.name),
            };
        }));
        const existingFreshServicesAndSchemas = existingServicesAndSchemas.filter((s) => {
            var _a, _b;
            return !((_b = (_a = s.schema) === null || _a === void 0 ? void 0 : _a.source.files) === null || _b === void 0 ? void 0 : _b.length);
        });
        if (existingFreshServicesAndSchemas.length) {
            const choices = existingFreshServicesAndSchemas.map((s) => {
                const serviceName = (0, names_1.parseServiceName)(s.service.name);
                return {
                    name: `${serviceName.location}/${serviceName.serviceId}`,
                    value: s,
                };
            });
            choices.push({ name: "Create a new service", value: undefined });
            const choice = await (0, prompt_1.promptOnce)({
                message: "Your project already has existing services. Which would you like to set up local files for?",
                type: "list",
                choices,
            });
            if (choice) {
                const serviceName = (0, names_1.parseServiceName)(choice.service.name);
                info.serviceId = serviceName.serviceId;
                info.locationId = serviceName.location;
                if (choice.schema) {
                    if ((_a = choice.schema.primaryDatasource.postgresql) === null || _a === void 0 ? void 0 : _a.cloudSql.instance) {
                        const instanceName = (0, names_1.parseCloudSQLInstanceName)((_b = choice.schema.primaryDatasource.postgresql) === null || _b === void 0 ? void 0 : _b.cloudSql.instance);
                        info.cloudSqlInstanceId = instanceName.instanceId;
                    }
                    info.cloudSqlDatabase = (_d = (_c = choice.schema.primaryDatasource.postgresql) === null || _c === void 0 ? void 0 : _c.database) !== null && _d !== void 0 ? _d : "";
                }
            }
        }
    }
    if (info.serviceId === "") {
        info.serviceId = await (0, prompt_1.promptOnce)({
            message: "What ID would you like to use for this service?",
            type: "input",
            default: "my-service",
        });
    }
    return info;
}
async function promptForCloudSQLInstance(setup, info) {
    if (setup.projectId) {
        const instances = await cloudsql.listInstances(setup.projectId);
        let choices = instances.map((i) => {
            return { name: i.name, value: i.name, location: i.region };
        });
        choices = choices.filter((c) => info.locationId === "" || info.locationId === c.location);
        if (choices.length) {
            const freeTrialInstanceId = await (0, freeTrial_1.checkForFreeTrialInstance)(setup.projectId);
            if (!freeTrialInstanceId) {
                choices.push({ name: "Create a new instance", value: "", location: "" });
            }
            info.cloudSqlInstanceId = await (0, prompt_1.promptOnce)({
                message: `Which CloudSQL instance would you like to use?`,
                type: "list",
                choices,
            });
            if (info.cloudSqlInstanceId !== "") {
                info.locationId = choices.find((c) => c.value === info.cloudSqlInstanceId).location;
            }
        }
    }
    if (info.cloudSqlInstanceId === "") {
        info.isNewInstance = true;
        info.cloudSqlInstanceId = await (0, prompt_1.promptOnce)({
            message: `What ID would you like to use for your new CloudSQL instance?`,
            type: "input",
            default: `fdc-sql`,
        });
    }
    if (info.locationId === "") {
        const choices = await locationChoices(setup);
        info.locationId = await (0, prompt_1.promptOnce)({
            message: "What location would like to use?",
            type: "list",
            choices,
        });
    }
    return info;
}
async function locationChoices(setup) {
    if (setup.projectId) {
        const locations = await (0, client_1.listLocations)(setup.projectId);
        return locations.map((l) => {
            return { name: l, value: l };
        });
    }
    else {
        return [
            { name: "us-central1", value: "us-central1" },
            { name: "europe-north1", value: "europe-north1" },
            { name: "europe-central2", value: "europe-central2" },
            { name: "europe-west1", value: "europe-west1" },
            { name: "southamerica-west1", value: "southamerica-west1" },
            { name: "us-east4", value: "us-east4" },
            { name: "us-west1", value: "us-west1" },
            { name: "asia-southeast1", value: "asia-southeast1" },
        ];
    }
}
async function promptForDatabase(setup, config, info) {
    if (!info.isNewInstance && setup.projectId) {
        try {
            const dbs = await cloudsql.listDatabases(setup.projectId, info.cloudSqlInstanceId);
            const choices = dbs.map((d) => {
                return { name: d.name, value: d.name };
            });
            choices.push({ name: "Create a new database", value: "" });
            if (dbs.length) {
                info.cloudSqlDatabase = await (0, prompt_1.promptOnce)({
                    message: `Which database in ${info.cloudSqlInstanceId} would you like to use?`,
                    type: "list",
                    choices,
                });
            }
        }
        catch (err) {
            logger_1.logger.debug(`[dataconnect] Cannot list databases during init: ${err}`);
        }
    }
    if (info.cloudSqlDatabase === "") {
        info.isNewDatabase = true;
        info.cloudSqlDatabase = await (0, prompt_1.promptOnce)({
            message: `What ID would you like to use for your new database in ${info.cloudSqlInstanceId}?`,
            type: "input",
            default: `fdcdb`,
        });
    }
    return info;
}
