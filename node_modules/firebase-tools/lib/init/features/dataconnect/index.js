"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doSetup = void 0;
const path_1 = require("path");
const prompt_1 = require("../../../prompt");
const fs_1 = require("fs");
const provisionCloudSql_1 = require("../../../dataconnect/provisionCloudSql");
const freeTrial_1 = require("../../../dataconnect/freeTrial");
const cloudsql = require("../../../gcp/cloudsql/cloudsqladmin");
const ensureApis_1 = require("../../../dataconnect/ensureApis");
const client_1 = require("../../../dataconnect/client");
const emulators_1 = require("../emulators");
const TEMPLATE_ROOT = (0, path_1.resolve)(__dirname, "../../../../templates/init/dataconnect/");
const DATACONNECT_YAML_TEMPLATE = (0, fs_1.readFileSync)((0, path_1.join)(TEMPLATE_ROOT, "dataconnect.yaml"), "utf8");
const CONNECTOR_YAML_TEMPLATE = (0, fs_1.readFileSync)((0, path_1.join)(TEMPLATE_ROOT, "connector.yaml"), "utf8");
const SCHEMA_TEMPLATE = (0, fs_1.readFileSync)((0, path_1.join)(TEMPLATE_ROOT, "schema.gql"), "utf8");
const QUERIES_TEMPLATE = (0, fs_1.readFileSync)((0, path_1.join)(TEMPLATE_ROOT, "queries.gql"), "utf8");
const MUTATIONS_TEMPLATE = (0, fs_1.readFileSync)((0, path_1.join)(TEMPLATE_ROOT, "mutations.gql"), "utf8");
async function doSetup(setup, config) {
    var _a, _b, _c;
    if (setup.projectId) {
        await (0, ensureApis_1.ensureApis)(setup.projectId);
    }
    const serviceId = await (0, prompt_1.promptOnce)({
        message: "What ID would you like to use for this service?",
        type: "input",
        default: "dataconnect",
    });
    const connectorId = await (0, prompt_1.promptOnce)({
        message: "What ID would you like to use for your connector?",
        type: "input",
        default: "my-connector",
    });
    let cloudSqlInstanceId = "";
    let newInstance = false;
    let locationId = "";
    if (setup.projectId) {
        const instances = await cloudsql.listInstances(setup.projectId);
        const choices = instances.map((i) => {
            return { name: i.name, value: i.name, location: i.region };
        });
        const freeTrialInstanceId = await (0, freeTrial_1.checkForFreeTrialInstance)(setup.projectId);
        if (!freeTrialInstanceId) {
            choices.push({ name: "Create a new instance", value: "", location: "" });
        }
        if (instances.length) {
            cloudSqlInstanceId = await (0, prompt_1.promptOnce)({
                message: `Which CloudSQL instance would you like to use?`,
                type: "list",
                choices,
            });
        }
        locationId = choices.find((c) => c.value === cloudSqlInstanceId).location;
    }
    if (cloudSqlInstanceId === "") {
        let locationOptions = [
            { name: "us-central1", value: "us-central1" },
            { name: "europe-north1", value: "europe-north1" },
            { name: "europe-central2", value: "europe-central2" },
            { name: "europe-west1", value: "europe-west1" },
            { name: "southamerica-west1", value: "southamerica-west1" },
            { name: "us-east4", value: "us-east4" },
            { name: "us-west1", value: "us-west1" },
            { name: "asia-southeast1", value: "asia-southeast1" },
        ];
        if (setup.projectId) {
            const locations = await (0, client_1.listLocations)(setup.projectId);
            locationOptions = locations.map((l) => {
                return { name: l, value: l };
            });
        }
        newInstance = true;
        cloudSqlInstanceId = await (0, prompt_1.promptOnce)({
            message: `What ID would you like to use for your new CloudSQL instance?`,
            type: "input",
            default: `dataconnect-test`,
        });
        locationId = await (0, prompt_1.promptOnce)({
            message: "What location would you use for this instance?",
            type: "list",
            choices: locationOptions,
        });
    }
    const dir = config.get("dataconnect.source") || "dataconnect";
    if (!config.has("dataconnect")) {
        config.set("dataconnect.source", dir);
        config.set("dataconnect.location", locationId);
    }
    let cloudSqlDatabase = "";
    let newDB = false;
    if (!newInstance && setup.projectId) {
        const dbs = await cloudsql.listDatabases(setup.projectId, cloudSqlInstanceId);
        const choices = dbs.map((d) => {
            return { name: d.name, value: d.name };
        });
        choices.push({ name: "Create a new database", value: "" });
        if (dbs.length) {
            cloudSqlDatabase = await (0, prompt_1.promptOnce)({
                message: `Which database in ${cloudSqlInstanceId} would you like to use?`,
                type: "list",
                choices,
            });
        }
    }
    if (cloudSqlDatabase === "") {
        newDB = true;
        cloudSqlDatabase = await (0, prompt_1.promptOnce)({
            message: `What ID would you like to use for your new database in ${cloudSqlInstanceId}?`,
            type: "input",
            default: `dataconnect`,
        });
    }
    const defaultConnectionString = (_c = (_b = (_a = setup.rcfile.dataconnectEmulatorConfig) === null || _a === void 0 ? void 0 : _a.postgres) === null || _b === void 0 ? void 0 : _b.localConnectionString) !== null && _c !== void 0 ? _c : emulators_1.DEFAULT_POSTGRES_CONNECTION;
    const localConnectionString = await (0, prompt_1.promptOnce)({
        type: "input",
        name: "localConnectionString",
        message: `What is the connection string of the local Postgres instance you would like to use with the Data Connect emulator?`,
        default: defaultConnectionString,
    });
    setup.rcfile.dataconnectEmulatorConfig = { postgres: { localConnectionString } };
    const subbedDataconnectYaml = subValues(DATACONNECT_YAML_TEMPLATE, {
        serviceId,
        cloudSqlInstanceId,
        cloudSqlDatabase,
        connectorId,
    });
    const subbedConnectorYaml = subValues(CONNECTOR_YAML_TEMPLATE, {
        serviceId,
        cloudSqlInstanceId,
        cloudSqlDatabase,
        connectorId,
    });
    await config.askWriteProjectFile((0, path_1.join)(dir, "dataconnect.yaml"), subbedDataconnectYaml);
    await config.askWriteProjectFile((0, path_1.join)(dir, "connector", "connector.yaml"), subbedConnectorYaml);
    await config.askWriteProjectFile((0, path_1.join)(dir, "schema", "schema.gql"), SCHEMA_TEMPLATE);
    await config.askWriteProjectFile((0, path_1.join)(dir, "connector", "queries.gql"), QUERIES_TEMPLATE);
    await config.askWriteProjectFile((0, path_1.join)(dir, "connector", "mutations.gql"), MUTATIONS_TEMPLATE);
    if (setup.projectId &&
        (newInstance || newDB) &&
        (await (0, prompt_1.confirm)({
            message: "Would you like to provision your CloudSQL instance and database now? This will take a few minutes.",
            default: true,
        }))) {
        await (0, provisionCloudSql_1.provisionCloudSql)({
            projectId: setup.projectId,
            locationId,
            instanceId: cloudSqlInstanceId,
            databaseId: cloudSqlDatabase,
            enableGoogleMlIntegration: false,
        });
    }
}
exports.doSetup = doSetup;
function subValues(template, replacementValues) {
    const replacements = {
        serviceId: "__serviceId__",
        cloudSqlDatabase: "__cloudSqlDatabase__",
        cloudSqlInstanceId: "__cloudSqlInstanceId__",
        connectorId: "__connectorId__",
    };
    let replaced = template;
    for (const [k, v] of Object.entries(replacementValues)) {
        replaced = replaced.replace(replacements[k], v);
    }
    return replaced;
}
