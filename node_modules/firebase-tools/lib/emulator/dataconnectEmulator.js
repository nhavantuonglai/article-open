"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkIfDataConnectEmulatorRunningOnAddress = exports.DataConnectEmulatorClient = exports.DataConnectEmulator = exports.dataConnectEmulatorEvents = void 0;
const childProcess = require("child_process");
const clc = require("colorette");
const api_1 = require("../api");
const constants_1 = require("./constants");
const downloadableEmulators_1 = require("./downloadableEmulators");
const types_1 = require("./types");
const error_1 = require("../error");
const emulatorLogger_1 = require("./emulatorLogger");
const types_2 = require("../dataconnect/types");
const portUtils_1 = require("./portUtils");
const apiv2_1 = require("../apiv2");
const registry_1 = require("./registry");
const logger_1 = require("../logger");
const load_1 = require("../dataconnect/load");
const utils_1 = require("../utils");
const events_1 = require("events");
exports.dataConnectEmulatorEvents = new events_1.EventEmitter();
class DataConnectEmulator {
    constructor(args) {
        this.args = args;
        this.usingExistingEmulator = false;
        this.logger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATACONNECT);
        this.emulatorClient = new DataConnectEmulatorClient();
    }
    async start() {
        try {
            const info = await DataConnectEmulator.build({ configDir: this.args.configDir });
            if ((0, types_2.requiresVector)(info.metadata)) {
                if (constants_1.Constants.isDemoProject(this.args.projectId)) {
                    this.logger.logLabeled("WARN", "Data Connect", "Detected a 'demo-' project, but vector embeddings require a real project. Operations that use vector_embed will fail.");
                }
                else {
                    this.logger.logLabeled("WARN", "Data Connect", "Operations that use vector_embed will make calls to production Vertex AI");
                }
            }
        }
        catch (err) {
            this.logger.log("DEBUG", `'fdc build' failed with error: ${err.message}`);
        }
        const alreadyRunning = await this.discoverRunningInstance();
        if (alreadyRunning) {
            this.logger.logLabeled("INFO", "Data Connect", "Detected an instance of the emulator already running with your service, reusing it. This emulator will not be shut down at the end of this command.");
            this.usingExistingEmulator = true;
            this.watchUnmanagedInstance();
        }
        else {
            await (0, downloadableEmulators_1.start)(types_1.Emulators.DATACONNECT, {
                auto_download: this.args.auto_download,
                listen: (0, portUtils_1.listenSpecsToString)(this.args.listen),
                config_dir: this.args.configDir,
            });
            this.usingExistingEmulator = false;
        }
        if (!(0, utils_1.isVSCodeExtension)()) {
            await this.connectToPostgres();
        }
        return;
    }
    async connect() {
        const emuInfo = await this.emulatorClient.getInfo();
        if (!emuInfo) {
            this.logger.logLabeled("ERROR", "Data Connect", "Could not connect to Data Connect emulator. Check dataconnect-debug.log for more details.");
            return Promise.reject();
        }
        return Promise.resolve();
    }
    async stop() {
        if (this.usingExistingEmulator) {
            this.logger.logLabeled("INFO", "Data Connect", "Skipping cleanup of Data Connect emulator, as it was not started by this process.");
            return;
        }
        return (0, downloadableEmulators_1.stop)(types_1.Emulators.DATACONNECT);
    }
    getInfo() {
        return {
            name: this.getName(),
            listen: this.args.listen,
            host: this.args.listen[0].address,
            port: this.args.listen[0].port,
            pid: (0, downloadableEmulators_1.getPID)(types_1.Emulators.DATACONNECT),
            timeout: 10000,
        };
    }
    getName() {
        return types_1.Emulators.DATACONNECT;
    }
    static async generate(args) {
        const commandInfo = await (0, downloadableEmulators_1.downloadIfNecessary)(types_1.Emulators.DATACONNECT);
        const cmd = [
            "--logtostderr",
            "-v=2",
            "generate",
            `--config_dir=${args.configDir}`,
            `--connector_id=${args.connectorId}`,
        ];
        const res = childProcess.spawnSync(commandInfo.binary, cmd, { encoding: "utf-8" });
        logger_1.logger.info(res.stderr);
        if (res.error) {
            throw new error_1.FirebaseError(`Error starting up Data Connect generate: ${res.error.message}`, {
                original: res.error,
            });
        }
        if (res.status !== 0) {
            throw new error_1.FirebaseError(`Unable to generate your Data Connect SDKs (exit code ${res.status}): ${res.stderr}`);
        }
        return res.stdout;
    }
    static async build(args) {
        var _a;
        const commandInfo = await (0, downloadableEmulators_1.downloadIfNecessary)(types_1.Emulators.DATACONNECT);
        const cmd = ["--logtostderr", "-v=2", "build", `--config_dir=${args.configDir}`];
        const res = childProcess.spawnSync(commandInfo.binary, cmd, { encoding: "utf-8" });
        if (res.error) {
            throw new error_1.FirebaseError(`Error starting up Data Connect build: ${res.error.message}`, {
                original: res.error,
            });
        }
        if (res.status !== 0) {
            throw new error_1.FirebaseError(`Unable to build your Data Connect schema and connectors (exit code ${res.status}): ${res.stderr}`);
        }
        if (res.stderr) {
            emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATACONNECT).log("DEBUG", res.stderr);
        }
        try {
            return JSON.parse(res.stdout);
        }
        catch (err) {
            throw new error_1.FirebaseError(`Unable to parse 'fdc build' output: ${(_a = res.stdout) !== null && _a !== void 0 ? _a : res.stderr}`);
        }
    }
    getLocalConectionString() {
        var _a, _b;
        if ((0, api_1.dataConnectLocalConnString)()) {
            return (0, api_1.dataConnectLocalConnString)();
        }
        return (_b = (_a = this.args.rc.getDataconnect()) === null || _a === void 0 ? void 0 : _a.postgres) === null || _b === void 0 ? void 0 : _b.localConnectionString;
    }
    async discoverRunningInstance() {
        const emuInfo = await this.emulatorClient.getInfo();
        if (!emuInfo) {
            return false;
        }
        const serviceInfo = await (0, load_1.load)(this.args.projectId, this.args.configDir);
        const sameService = emuInfo.services.find((s) => serviceInfo.dataConnectYaml.serviceId === s.serviceId);
        if (!sameService) {
            throw new error_1.FirebaseError(`There is a Data Connect emulator already running on ${this.args.listen[0].address}:${this.args.listen[0].port}, but it is emulating a different service. Please stop that instance of the Data Connect emulator, or specify a different port in 'firebase.json'`);
        }
        if (sameService.connectionString &&
            sameService.connectionString !== this.getLocalConectionString()) {
            throw new error_1.FirebaseError(`There is a Data Connect emulator already running, but it is using a different Postgres connection string. Please stop that instance of the Data Connect emulator, or specify a different port in 'firebase.json'`);
        }
        return true;
    }
    watchUnmanagedInstance() {
        return setInterval(async () => {
            if (!this.usingExistingEmulator) {
                return;
            }
            const emuInfo = await this.emulatorClient.getInfo();
            if (!emuInfo) {
                this.logger.logLabeled("INFO", "Data Connect", "The already running emulator seems to have shut down. Starting a new instance of the Data Connect emulator...");
                await this.start();
                exports.dataConnectEmulatorEvents.emit("restart");
            }
        }, 5000);
    }
    async connectToPostgres(localConnectionString, database, serviceId) {
        const connectionString = localConnectionString !== null && localConnectionString !== void 0 ? localConnectionString : this.getLocalConectionString();
        if (!connectionString) {
            const msg = `No Postgres connection string found in '.firebaserc'. The Data Connect emulator will not be able to execute operations.
Run ${clc.bold("firebase setup:emulators:dataconnect")} to set up a Postgres connection.`;
            throw new error_1.FirebaseError(msg);
        }
        const MAX_RETRIES = 3;
        for (let i = 1; i <= MAX_RETRIES; i++) {
            try {
                this.logger.logLabeled("DEBUG", "Data Connect", `Connecting to ${connectionString}}`);
                await this.emulatorClient.configureEmulator({ connectionString, database, serviceId });
                return true;
            }
            catch (err) {
                if (i === MAX_RETRIES) {
                    throw err;
                }
                this.logger.logLabeled("DEBUG", "Data Connect", `Retrying connectToPostgress call (${i} of ${MAX_RETRIES} attempts): ${err}`);
                await new Promise((resolve) => setTimeout(resolve, 800));
            }
        }
        return false;
    }
}
exports.DataConnectEmulator = DataConnectEmulator;
class DataConnectEmulatorClient {
    constructor() {
        this.client = undefined;
    }
    async configureEmulator(body) {
        var _a, _b;
        if (!this.client) {
            this.client = registry_1.EmulatorRegistry.client(types_1.Emulators.DATACONNECT);
        }
        try {
            const res = await this.client.post("emulator/configure", body);
            return res;
        }
        catch (err) {
            if (err.status === 500) {
                throw new error_1.FirebaseError(`Data Connect emulator: ${(_b = (_a = err === null || err === void 0 ? void 0 : err.context) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.message}`);
            }
            throw err;
        }
    }
    async getInfo() {
        if (!this.client) {
            this.client = registry_1.EmulatorRegistry.client(types_1.Emulators.DATACONNECT);
        }
        return getInfo(this.client);
    }
}
exports.DataConnectEmulatorClient = DataConnectEmulatorClient;
async function checkIfDataConnectEmulatorRunningOnAddress(l) {
    const client = new apiv2_1.Client({
        urlPrefix: `http:/${l.family === "IPv6" ? `[${l.address}]` : l.address}:${l.port}`,
        auth: false,
    });
    return getInfo(client);
}
exports.checkIfDataConnectEmulatorRunningOnAddress = checkIfDataConnectEmulatorRunningOnAddress;
async function getInfo(client) {
    try {
        const res = await client.get("emulator/info");
        return res.body;
    }
    catch (err) {
        return;
    }
}
