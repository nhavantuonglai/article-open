"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataConnectEmulator = void 0;
const childProcess = require("child_process");
const api_1 = require("../api");
const constants_1 = require("./constants");
const downloadableEmulators_1 = require("./downloadableEmulators");
const types_1 = require("./types");
const error_1 = require("../error");
const emulatorLogger_1 = require("./emulatorLogger");
const types_2 = require("../dataconnect/types");
const portUtils_1 = require("./portUtils");
class DataConnectEmulator {
    constructor(args) {
        this.args = args;
        this.logger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATACONNECT);
    }
    async start() {
        this.logger.log("DEBUG", `Using Postgres connection string: ${this.getLocalConectionString()}`);
        const info = await DataConnectEmulator.build({ configDir: this.args.configDir });
        if ((0, types_2.requiresVector)(info.metadata)) {
            if (constants_1.Constants.isDemoProject(this.args.projectId)) {
                this.logger.logLabeled("WARN", "Data Connect", "Detected a 'demo-' project, but vector embeddings require a real project. Operations that use vector_embed will fail.");
            }
            else {
                this.logger.logLabeled("WARN", "Data Connect", "Operations that use vector_embed will make calls to production Vertex AI");
            }
        }
        return (0, downloadableEmulators_1.start)(types_1.Emulators.DATACONNECT, Object.assign(Object.assign({}, this.args), { listen: (0, portUtils_1.listenSpecsToString)(this.args.listen), config_dir: this.args.configDir, local_connection_string: this.getLocalConectionString(), project_id: this.args.projectId, service_location: this.args.locationId }));
    }
    connect() {
        return Promise.resolve();
    }
    stop() {
        return (0, downloadableEmulators_1.stop)(types_1.Emulators.DATACONNECT);
    }
    getInfo() {
        return {
            name: this.getName(),
            listen: this.args.listen,
            host: this.args.listen[0].address,
            port: this.args.listen[0].port,
            pid: (0, downloadableEmulators_1.getPID)(types_1.Emulators.DATACONNECT),
            timeout: 10000,
        };
    }
    getName() {
        return types_1.Emulators.DATACONNECT;
    }
    static async generate(args) {
        const commandInfo = await (0, downloadableEmulators_1.downloadIfNecessary)(types_1.Emulators.DATACONNECT);
        const cmd = [
            "generate",
            `--service_location=${args.locationId}`,
            `--config_dir=${args.configDir}`,
            `--connector_id=${args.connectorId}`,
        ];
        const res = childProcess.spawnSync(commandInfo.binary, cmd, { encoding: "utf-8" });
        if (res.error) {
            throw new error_1.FirebaseError(`Error starting up Data Connect generate: ${res.error.message}`, {
                original: res.error,
            });
        }
        return res.stdout;
    }
    static async build(args) {
        var _a;
        const commandInfo = await (0, downloadableEmulators_1.downloadIfNecessary)(types_1.Emulators.DATACONNECT);
        const cmd = ["build", `--config_dir=${args.configDir}`];
        const res = childProcess.spawnSync(commandInfo.binary, cmd, { encoding: "utf-8" });
        if (res.error) {
            throw new error_1.FirebaseError(`Error starting up Data Connect build: ${res.error.message}`, {
                original: res.error,
            });
        }
        if (res.stderr) {
            throw new error_1.FirebaseError(`Unable to build your Data Connect schema and connectors: ${res.stderr}`);
        }
        try {
            return JSON.parse(res.stdout);
        }
        catch (err) {
            throw new error_1.FirebaseError(`Unable to parse 'fdc build' output: ${(_a = res.stdout) !== null && _a !== void 0 ? _a : res.stderr}`);
        }
    }
    getLocalConectionString() {
        var _a, _b;
        if ((0, api_1.dataConnectLocalConnString)()) {
            return (0, api_1.dataConnectLocalConnString)();
        }
        return (_b = (_a = this.args.rc.getDataconnect()) === null || _a === void 0 ? void 0 : _a.postgres) === null || _b === void 0 ? void 0 : _b.localConnectionString;
    }
}
exports.DataConnectEmulator = DataConnectEmulator;
